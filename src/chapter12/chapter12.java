package chapter12;

public class chapter12 {

    //////* 창발성 *//////
    //창발성 : 하위계층(구성 요소)에는 없는 특성이나 행동이 상위계층(전체 구조)에서 자발적으로 돌연히 출현하는 현상

    /* 창발적 설계로 깔끔한 코드를 구현하자 */
    //단순한 설계 규칙 네 가지를 따르면 소프트웨어 설계 품질이 크게 높아진다. (중요한 순서대로)
    //1. 모든 테스트를 실행한다.
    //2. 중복을 없앤다.
    //3. 프로그래머 의도를 표현한다.
    //4. 클래스와 메서드 수를 최소로 줄인다.

    //1. 모든 테스트를 실행하라.
    //시스템이 의도한 대로 돌아가는지 검증하기 위해선 테스트가 필요하다.
    //테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아진다.
    //크기가 작고 목적 하나만 수행하는 클래스가 나온다.
    //테스트 케이스를 많이 작성할수록 개발자는 DIP(의존 관계 역전 원칙)와 같은 원칙을 적용하고 의존성 주입, 인터페이스, 추상화 등과 같은 도구를 사용해 결합도를 낮춘다.
    //객체 지향 방법론이 지향하는 목표를 저절로 달성한다.

    //2. 리팩터링
    //테스트 케이스를 모두 작성했다면 코드와 클래스를 정리하라.
    //시스템이 깨질까 걱정할 필요가 없다.

    //2-1. 중복을 없애라
    //중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻한다.
    //<중복>
    int size() {}
        boolean isEmpty() {}
    //
    //<중복 제거>
    boolean isEmpty() {
        return 0 == size();
    }
    //공통적인 코드를 새 메서드로 뽑아라
    //
    //TEMPLATE METHOD 패턴은 고차원 중복을 제거할 목적으로 자주 사용하는 기법이다.
    //상속을 통해 중복 제거

    //2-2. 표현하라
    //나중에 코드를 유지보수할 사람을 위해 개발자의 의도를 분명히 표현해야 한다.
    //좋은 이름, 함수와 클래스 크기 최소화, 표준 명칭 사용, 단위 테스트 케이스 꼼꼼히 작성

    //2-3. 클래스와 메서드 수를 최소로 줄여라
    //위 개념들도 극단으로 치달으면 득보다 실이 많아진다.
    //따라서 클래스와 메서드 수를 가능한 줄이라고 제안한다. (무의미한 클래스, 메서드를 작성하지 마라)
    //함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 것이 목표이다.
    //하지만 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다.

}
