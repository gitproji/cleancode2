package chapter9;

public class chapter9 {

    //////* 단위 테스트 *//////

    /* TDD 법칙 세 가지 */
    // 1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다
    // 2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다
    // 3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다
    //위 세가지 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶인다.
    //이렇게 일하면 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나오지만, 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.


    /* 깨끗한 테스트 코드 유지하기 */
    //실제 코드가 바뀌면 테스트 코드도 바뀌어야하기 때문에 지저분할수록 변경하기 어려워진다.
    //실제 코드 못지 않게 깨끗하게 짜야 한다.

    //테스트는 유연성, 유지보수성, 재사용성을 제공한다.
    //테스트 케이스가 없다면 모든 변경이 잠정적인 버그다.


    /* 깨끗한 테스트 코드 */
    //깨끗한 테스트 코드에서 가장 중요한 것은 가독성이며, 이를 높이려면 명료성, 단순성, 풍부한 표현력이 필요하다.
    //build-operate-check 패턴 - 테스트 자료 만들고, 조작, 결과가 올바른지 확인

    //단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다.
    //테스트 환경에서는 메모리나 효율과 무관하다.


    /* 테스트 당 assert 하나 */
    //assert문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.
    //given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두면 중복을 제거할 수 있다.
    //아니면 완전히 독자적인 테스트 클래스를 만들어 @Before 함수에 given/when 부분을 넣고 @Test 함수에 then 부분을 넣어도 된다.
    //하지만 이것저것 감안해 보면 assert문을 여럿 사용하는 편이 좋다고 생각한다???????.....
    //아무튼 assert문 개수는 최대한 줄이는 게 좋다.

    //테스트 함수마다 한 개념만 테스트하라


    /* F.I.R.S.T */
    //깨끗한 테스트 규칙
    //Fast(빠르게) : 테스트는 빨리 돌아야 한다.
    //Independent(독립적으로) : 각 테스트는 서로 의존하면 안된다.
    //Repeatable(반복가능하게) : 테스트는 어떤 환경에서도 반복 가능해야 한다.
    //Self-Validating(자가검증하는) : 테스트는 성공 아니면 실패로 결과를 내야한다.
    //Timely(적시에) : 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

    //테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문에 어쩌면 실제 코드보다 더 중요할지도 모른다.
    //그러므로 지속적으로 깨끗하게 관리하자.
    //테스트 API를 구현해 도메인 특화 언어를 만들자.
}
