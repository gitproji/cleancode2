package chapter8;

public class chapter8 {

    //////* 경계 *//////

    /* 외부 코드 사용하기 */
    //프레임워크 제공자는 적용성을 최대한 넓히려고 하고 사용자는 자신의 요구에 집중하는 인터페이스를 바란다.
    //이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다.
    //<나쁜 코드>
    Map sensors = new HashMap();
    Sensor s = (Sensor)sensors.get(sensorId);
    //
    //<보완한 코드> -> 사용자에게 필요하지 않은 기능까지 제공한다는 문제는 해결하지 못한다.
    Map<String, Sensor> sensors = new HashMap<Sensor>();
    ...
    Sensor s = sensors.get(sensorId);
    //프로그램에서 Map<String, Sensor> 인스턴스를 여기저기로 넘긴다면, Map 인터페이스가 변할 경우, 수정할 코드가 상당히 많아진다.
    //
    //<좋은 코드>
    public class Sensors {
        private Map sensors = new HashMap();

        public Sensor getById(String id) {
            return (Sensor) sensors.get(id);
        }
        //이하 생략
    }
    //경계 인터페이스인 Map을 Sensors 안으로 숨겨서 Map 인터페이스가 변하더라도 프로그램에 영향을 미치지 않는다.
    //
    //Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.
    //Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.


    /* 경계 살피고 익히기 */
    //곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방식
    //이를 학습 테스트라 부른다.
    //학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다.
    //학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.


    /* log4j 익히기 */
    //초기화 방법 책보면 될듯..


    /* 학습 테스트는 공짜 이상이다 */
    //학습 테스트는 이해도를 높여주는 정확한 실험이다.
    //패키지 새 버전이 나올 때마다 새로운 위험이 생기는데, 우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 밝혀낸다.
    //경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.


    /* 아직 존재하지 않는 코드를 사용하기 */
    //아는 코드와 모르는 코드를 분리하는 경계
    //우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다.
    //또한 코드 가독성도 높아지고 코드 의도도 분명해진다.
    //테스트도 아주 편하다.


    /* 깨끗한 경계 */
    //소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않다.
    //엄청난 시간과 노력와 재작업을 요구하지 않는다.
    //통제하지 못하는 코드를 사용할 때는 너무 많은 투자를 하거나 향후 변경 비용이 지나치게 커지지 않도록 각별히 주의해야 한다.
    //
    //경계에 위치하는 코드는 깔끔히 분리한다.
    //또한 기대치를 정의하는 테스트 케이스도 작성한다.
    //
    //외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.
    //코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때 변경할 코드도 줄어든다.



}
