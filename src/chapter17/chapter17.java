package chapter17;

public class chapter17 {

    //////* 냄새와 휴리스틱(어림짐작) *//////

    /* 주석 */
    //다른 시스템에 저장할 정보는 주석으로 x(변경이력 등)
    //쓸모 없어진 주석은 빠르게 지워라
    //코드만으로 충분한데 구구절절 설명하는 중복된 주석은 달지마라
    //주석을 달거면 최대한 신중하고 간결하고 명료하게 작성하라
    //소스 관리 시스템이 코드를 기억하므로, 주석 처리된 코드는 지워라


    /* 환경 */
    //빌드는 간단히 한 단계로 끝나야 한다 -> 무슨소리..?
    //모든 단위 테스트는 한번에 실행되어야 한다


    /* 함수 */
    //함수에서 인수 개수는 작을수록 좋다
    //독자는 인수를 입력으로 간주하므로 출력 인수를 쓰지마라
    //boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거다. 플래그 인수는 피해라
    //아무도 호출하지 않는 함수는 삭제하라


    /* 일반 */
    //소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다. 언어수와 범위를 최대한 줄이도록 노력하라
    //함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다
    //모든 경계 조건을 찾아내고, 테스트 케이스를 작성하라
    //실패하는 테스트 케이스를 제껴두지 마라
    //코드 중복을 없애는 것은 모든 테스트를 통과하라는 규칙 다음으로 중요하다
    //중복된 코드를 하위 루틴이나 다른 클래스로 분리하라
    //template method 패턴이나 strategy 패턴으로 중복을 제거하라
    //BCNF는 데이터베이스 스키마에서 중복을 제거하는 전략이다
    //추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다
    //모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다
    //고차원 개념과 저차원 개념을 섞어선 안된다
    //고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로 부터 분리해서 독립성을 보장한다
    //기초 클래스와 파생 클래스를 다른 JAR 파일로 배포하면 독립적인 개별 컴포넌트 단위로 시스템을 배치할 수 있다
    //이러면 변경이 시스템에 미치는 영향이 아주 작아짐
    //잘 정의된 인터페이스는 많은 함수를 제공하지 않는다
    //클래스가 제공하는 메서드 수는 작을수록 좋다.
    //인터페이스를 매우 작고 깐깐하게 만들어 정보를 제한해 결합도를 낮춰라
    //실행되지 않는 코드는 지워라
    //변수와 함수는 가깝게 정의하며, 지역변수는 처음으로 사용하기 직전에 수직으로 가까운곳에 선언
    //비공개 함수는 처음으로 호출한 직후에 정의한다
    //구현 방식, 변수 이름, 메서드 이름 등 일관성을 유지하라
    //비어있는 기본 생성자는 필요없다. 제거하라
    //함수, 상수, 변수를 선어언할 때 올바른 위치에 선언하여 인위적인 결합을 피하라
    //클래스 메서드는 자기 클래스 변수와 함수에 관심을 가져야한다. 다른 클래스 관심x
    //선택자 인수(boolean)는 목적을 기억하기 어려울 뿐 아니라 각 선택자 인수가 여러 함수를 하나로 조합한다
    //boolean 뿐만 아니라 함수 동작을 제어하려는 인수는 바람직하지 않다
    //의도를 분명히 밝혀라
    //static 함수보다 인스턴스 함수가 더 좋다
    //static 함수로 정의할때 재정의할 가능성은 없는지 꼼꼼히 따져봐라
    //프로그램 가독성을 높이는 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 것이다
    //알고리즘을 이해해야한다
    //한 모듈이 다른 모듈에 의존한다면 물리적인 의존성도 있어야 한다
    //switch를 선택하기 전에 다형성을 먼저 고려하라
    //팀이 정한 표준을 따라야 한다
    //숫자 대신 명명된 상수를 써라
    //잠금과 트랜잭션 관리를 건너뛰는 행동은 옳지않다
    //List로 선언할 변수를 ArrayList로 선언하는 것은 지나친 제약이고, 모든 변수를 protected로 선언한 코드는 무절제하다
    //코드를 결정할 땐 결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 한다
    //설계 결정을 강제할 때는 규칙보다 관례를 사용하라
    //조건문을 작성할 때 부울보다 의도를 분명히 밝히는 함수로 표현하라
    //부정 조건보다 긍정 조건을 사용하라
    if (buffer.shouldCompact()) (o)
    if (!buffer.shouldNotCompact()) (x)
    //함수는 한 가지 임무만 수행하는 작은 함수 여럿으로 나눠야 한다
    //함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러내야 한다 ->다시
    //코드 구조를 일관성있게 작성하라
    //다른 클래스의 유틸리티가 아닌 public 클래스는 자신이 아닌 클래스 범위 안에서 선언하면 안 된다
    //경계 조건은 한 곳에서 별도로 처리하라
    //함수 내 모든 문장은 추상화 수준이 동일해야 하고, 그 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야한다
    //기본값 상수나 설정 관련 상수는 고차원 함수에서 저차원 함수를 호출할 때 인수로 넘긴다
    //한 모듈은 주변 모듈을 모를수록 좋다. 직접 사용하든 모듈만 알아야 한다는 뜻이다


    /* 자바 */
    //패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 이용해 패키지 전체를 가져와라
    //import package.*;
    //클래스를 import하면 그 클래스가 반드시 존재해야 하지만, 와일드로 패키지를 지정하면 특정 클래스가 존재할 필요는 없다
    //레거시 코드라도 와일드 카드 import문을 사용하는 편이 좋다
    //상수를 상속 계측 맨 위에 숨겨놓으면 안된다
    //static import를 사용하라
    //상수 대신 enum을 사용하라
    //가독성의 90%는 이름이 결정한다. 따라서 서술적인 이름을 사용하라
    //예상가능한 이름으로 지어야한다
    //구현을 드러내는 이름은 피하라. 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라
    //표준 명명법을 사용하라
    //이름 길이는 범위 길이에 비례해야 한다
    //이름에 유형정보나 범위정보를 넣어선 안된다
    //이름으로 부수효과도 설명하라 getOos -> createOrReturnOos


    /* 테스트 */
    //테스트 케이스는 깨질 만한 부분을 모두 테스트 해야 한다.
    //커버리지 도구를 사용하여 잘못된 부분을 쉽게 찾을 수 있다
    //사소한 테스트도 건너뛰지 마라
    //불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 @Ignore를 붙여 표현한다
    //경계 조건과 버그는 신경써서 테스트한다
    //꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다
    //통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다
    //테스트 케이스가 빠르게 동작하도록 노력하라


}
