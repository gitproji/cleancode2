package chapter11;

public class chapter11 {

    //////* 시스템 *//////

    //적절한 추상화와 모듈화를 통해 시스템이 효율적으로 돌아가도록 하라.

    /* 시스템 제작과 시스템 사용을 분리하라 */
    //소프트웨어 시스템은 '애플리케이션 객체를 제작하고 의존성을 서로 연결하는' 준비과정과
    //'준비 과정 이후에 이어지는' 런타임 로직을 분리해야 한다.

    //관심사 분리는 가장 오래되고 가장 중요한 설계 기법 중 하나다.

    //시작 단계를 분리하지 않은 전형적인 예 -> 초기화 지연, 계산 지연 기법
    public Service getService() {
        if (service == null)
            service = new MyServiceImpl(...);
        return service;
    }
    //장점1. 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다. 그만큼 빨라진다.
    //장점2. 어떤 경우에도 null 포인터를 반환하지 않는다.
    //
    //하지만 의존성을 해결하지 않으면 컴파일이 안된다.
    //또, 단일 책임 원칙을 깬다.
    //가장 큰 우려는 MyServiceImpl이 모든 상황에 적합한 객체인지 모른다는 사실이다.

    //체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 안된다.
    //설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.

    //(1) Main 분리
    //생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되면
    //애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모른다.

    //(2) 팩토리
    //객체가 생성되는 시점을 애플리케이션이 결정해야할 땐 ABSTRACT FACTORY 패턴을 사용한다.

    //(3) 의존성 주입 -> 다시읽어보기


    /* 확장 */
    //오늘 주어진 사용자 스토리에 맞춰 시스템을 구현하고, 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.
    //이것이 반복적이고 점진적인 애자일 방식의 핵심이다.
    //테스트 주도 개발(TDD), 리팩터링, 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.
    //관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

    //이후는 다시 읽어보기


    /* 자바 프록시 */
    //프록시 예 : 개별 객체나 클래스에서 메서드 호출을 감싸는 경우
    //프록시를 사용하면 깨끗한 코드를 작성하기 어렵고, 시스템 단위로 실행 지점을 명시하는 메커니즘도 제공하지 않는다.


    /* 순수 자바 AOP 프레임워크 */
    //여러 자바 프레임워크는 내부적으로 프록시를 사용한다.

    //POJO : 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다.

    /* AspectJ 관점 */


    /* 테스트 주도 시스템 아키텍처 구축 */
    //코드 수준에서 아키텍처 관심사를 분리할 수 있다면 진정한 테스트 주도 아키텍처 구축이 가능해진다.
    //BDUF(구현을 시작하기 전에 앞으로 벌어질 모든 사항을 설계하는 기법)를 추구할 필요가 없다.


    /* 의사 결정을 최적화하라 */
    //모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다.
    //성급하게 결정하는것 보다 최대한 정보를 모아 가능한 마지막 순간까지 결정을 미루는 방법이 최선이 될 수 있다.
    //POJO 시스템은 기민함을 제공한다.


    /* 명백한 가치가 있을 때 표준을 현명하게 사용하라 */
    //표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉬운 등 좋은 점이 많지만, 때로는 표준을 만드는 시간이 너무 오래 걸려
    //업계가 기다리지 못한다. 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다.


    /* 시스템은 도메인 특화 언어(DSL)가 필요하다 */
    //DSL : 간단한 스크립트 언어나 표준 언어로 구현한 API
    //DSL로 짠 코드는 도메인 전문가가 작성한 구조적인 산문처럼 읽힌다.
    //DSL을 효과적으로 사용한다면 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다.
    //그래서 개발자가 적절한 추상화 수준에서 코드 의도를 표현할 수 있다.


    //깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다.
    //도메인 논리가 흐려지면 제품 품질이 떨어진다.
    //POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야 한다.
    //무엇을 설계하든 실제로 돌아가는 가장 단순한 수단을 사용해야한다.

}
